package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"

	gqlutils "github.com/lwinmgmg/user-go/graph/gql-utils"
	"github.com/lwinmgmg/user-go/graph/model"
	"github.com/lwinmgmg/user-go/internal/models"
)

// Partners is the resolver for the partners field.
func (r *queryResolver) Partners(ctx context.Context) ([]*model.Partner, error) {
	partners, err := models.GetPartners(r.RoDb)
	if err != nil {
		return nil, err
	}
	partnerLen := len(partners)
	gPartners := make([]*model.Partner, 0, partnerLen)
	for i := 0; i < len(partners); i++ {
		gPartner := &model.Partner{
			ID:               int(partners[i].ID),
			FirstName:        partners[i].FirstName,
			LastName:         &partners[i].LastName,
			Email:            partners[i].Email,
			Phone:            partners[i].Phone,
			IsEmailConfirmed: partners[i].IsEmailConfirmed,
			IsPhoneConfirmed: partners[i].IsPhoneConfirmed,
			Code:             partners[i].Code,
		}
		gPartners = append(gPartners, gPartner)
	}
	return gPartners, nil
}

// Partner is the resolver for the partner field.
func (r *queryResolver) Partner(ctx context.Context, id int) (*model.Partner, error) {
	partner := models.Partner{}
	if err := partner.GetPartnerByID(uint(id), r.RoDb); err != nil {
		return nil, err
	}
	return &model.Partner{
		ID:               int(partner.ID),
		FirstName:        partner.FirstName,
		LastName:         &partner.LastName,
		Email:            partner.Email,
		Phone:            partner.Phone,
		IsEmailConfirmed: partner.IsEmailConfirmed,
		IsPhoneConfirmed: partner.IsPhoneConfirmed,
		Code:             partner.Code,
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := models.GetUsers(r.RoDb)
	if err != nil {
		return nil, err
	}
	userLen := len(users)
	gUsers := make([]*model.User, 0, userLen)
	for i := 0; i < len(users); i++ {
		gUser := &model.User{
			ID:              int(users[i].ID),
			Username:        users[i].Username,
			Password:        string(users[i].Password),
			Code:            users[i].Code,
			PartnerID:       int(users[i].PartnerID),
			OtpURL:          &users[i].OtpUrl,
			IsAuthenticator: users[i].IsAuthenticator,
		}
		gUsers = append(gUsers, gUser)
	}
	return gUsers, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id int) (*model.User, error) {
	user, err := models.GetUserById(uint(id), r.RoDb)
	if err != nil {
		return nil, err
	}
	return gqlutils.ContructUser(user), nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
